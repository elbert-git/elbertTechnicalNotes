<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../../style.css">
    <base target="_parent">
  </head>
  
  <body class="ck-content">
     <h1>Shaders</h1>

    
<h2>Shaders</h2>
    <p>They are the programs that render images with 3D data. They are written
      as GLSL files. They process a lot of data like:</p>
    <ul>
      <li>vertex positions</li>
      <li>texture</li>
      <li>light parameters</li>
      <li>camera transformations and many more</li>
    </ul>
    <h2>Creating Shaders</h2>
    <p>To use custom shaders simply use a raw shader material. It's a &nbsp;type
      of material where you supply your own shader</p><pre><code class="language-text-plain">const material = new THREE.RawShaderMaterial({
    vertexShader: `shaderStringGoesHere`,
    fragmentShader: `shaderStringGoesHere`
})</code></pre>
    <p>Inside the object properties are where you put the shader materials. You
      can use backticks to write in the shader contructor. Or import a raw string
      using vite.&nbsp;</p><pre><code class="language-text-plain">import shaderString from './shader.glsl?raw'</code></pre>
    <p>There are 2 types of shaders as you an see</p>
    <h3>Using ‘ShaderMaterial’</h3>
    <p>The above uses raw shader material. which is pretty plane. Use ShaderMaterial
      to have some sane default shader parameters and varyings</p>
    <p>The below attributes, uniforms and varyings should be already set in the
      shaders. no need to define them again. Just use them as initated variables</p>
    <ul>
      <li>uniform mat4 projectionMatrix;</li>
      <li>uniform mat4 viewMatrix;</li>
      <li>uniform mat4 modelMatrix;</li>
      <li>attribute vec3 position;</li>
      <li>attribute vec2 uv;</li>
      <li>precision mediump float;</li>
    </ul>
    <h2>Vertex, Fragments and Parameters</h2>
    <h5><a href="Shaders/Understanding%20Vertex%20Shaders.html">Vertex Shaders</a></h5>
    <p>Handle positionling vertices in 2D space. taking into consideration the
      vertex data and camera parameters</p>
    <h5><a href="Shaders/Understanding%20Fragment%20Shaders.html">Fragment shaders</a></h5>
    <p>These color in portion of the screens. These actually shade the color
      in depending on the lights. Fragment shaders always run after vertex shaders.</p>
    <section
    class="include-note" data-note-id="3hGYwhl7DmLq" data-box-size="small">&nbsp;</section>
      <h2>Why bother with custom shaders</h2>
      <p>In most 3D contexts there are pre-made shaders given to you. Covering
        most needs. Things like a PBR shaders are uber shaders that cover everything
        you would most likely need.&nbsp;</p>
      <p>But these come at the expense of performance if you can write only what
        you need. Performance will be drastically improved.&nbsp;</p>
      <p>They also come in handy for very specific visual requirements</p>
      <h2>Futher reading</h2>
      <ul>
        <li>The Book of Shaders: <a href="https://thebookofshaders.com/"><u>https://thebookofshaders.com/</u></a>
        </li>
        <li>ShaderToy: <a href="https://www.shadertoy.com/">https://www.shadertoy.com/</a>
        </li>
        <li>The Art of Code Youtube Channel: <a href="https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg">https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg</a>
        </li>
        <li>Lewis Lepton Youtube Channel: <a href="https://www.youtube.com/channel/UC8Wzk_R1GoPkPqLo-obU_kQ">https://www.youtube.com/channel/UC8Wzk_R1GoPkPqLo-obU_kQ</a>
        </li>
      </ul>
  </body>

</html>